# AI REPORT
## Lab 05: TypeScript & Props Validation
### Student Name: Нурканат Алиар
### Lab 5.1: Typed Components & Props Validation

## 1. Информация об использовании AI 
- **Инструмент:** Google Gemini
- **Дата:** 2026-02-14

## 2. Конкретные промпты

### Промпт 1:
"Объясни задачи лабораторной работы 05 по React и TypeScript (TypeScript & Props Validation)"

**Что получил:** Краткий обзор процесса миграции с JSX на TSX, важность типизации пропсов и использования интерфейсов вместо PropTypes.

### Промпт 2:
"Как правильно типизировать пропс children в React компоненте на TypeScript и как сделать другой пропс необязательным?"

**Что получил:** Рекомендацию использовать `React.ReactNode` для `children` и оператор `?` (вопросительный знак) перед двоеточием для опциональных пропсов.

### Промпт 3:
"Как создать Union Type для ограниченного набора строковых значений, например для уровней навыков: Beginner, Intermediate, Expert?"

**Что получил:** Синтаксис создания `type SkillLevel = 'Beginner' | 'Intermediate' | 'Expert';`, который предотвращает ввод невалидных строк.

## 3. Модификация и проверка
- **Архитектура:** Самостоятельно вынес интерфейсы `User` и `Skill` в отдельный файл `types.ts`, чтобы обеспечить их переиспользование между компонентами.
- **Условный рендеринг:** Написал логику `getLevelColor` для компонента `SkillList`, которая меняет цвет текста в зависимости от уровня навыка.
- **Strict Mode:** Проверил `tsconfig.json` на наличие `"strict": true` и исправил мелкие ошибки типизации, возникшие из-за строгого режима.

## 4. Что узнал
- Понял разницу между **Interface** (для объектов) и **Type Alias** (для объединений и примитивов).
- Узнал, как TypeScript отлавливает ошибки типизации пропсов еще на этапе написания кода, в отличие от `PropTypes`, которые работают только во время выполнения.
- Научился использовать значения по умолчанию для опциональных пропсов в деструктуризации.

## 5. Процент использования
- 25% — AI (помощь с синтаксисом React.ReactNode и структурой Union типов).
- 75% — Самостоятельное написание TSX-кода, настройка Vite-проекта и типизация бизнес-логики.

---

### Lab 5.2: Typing State & Event Handlers

## 1. Информация об использовании AI
- **Инструмент:** Google Gemini
- **Дата:** 2026-02-14

## 2. Конкретные промпты

### Промпт 1:
"Как использовать Generics в хуке useState для массива объектов типа User?"

**Что получил:** Пример синтаксиса `useState<User[]>([])`, который гарантирует, что состояние будет содержать только объекты, соответствующие интерфейсу User.

### Промпт 2:
"Какие типы данных использовать для обработчиков событий onChange (поле ввода) и onClick (кнопка) в React + TypeScript?"

**Что получил:** Определение `React.ChangeEvent<HTMLInputElement>` для ввода текста и `React.MouseEvent<HTMLButtonElement>` для кликов.

### Промпт 3:
"Как типизировать функцию фильтрации массива объектов, чтобы избежать использования 'any'?"

**Что получил:** Пример использования метода `.filter()` с автоматическим выводом типов на основе типизированного состояния.

## 3. Модификация и проверка
- **Безопасность:** Полностью исключил использование ключевого слова `any`. Все переменные и параметры функций имеют четкие определения.
- **UI:** Реализовал логику отображения сообщения "No results found" через тернарный оператор в JSX.
- **Интеграция:** Переиспользовал компонент `UserCard` из первой части внутри списка результатов поиска, обеспечив передачу правильных данных.

## 4. Что узнал
- Изучил работу **Generics** в React-хуках для обеспечения типобезопасности динамических данных.
- Понял важность типизации **Synthetic Events** для получения доступа к специфическим свойствам элементов (например, `target.value`).
- Убедился, что TypeScript значительно облегчает рефакторинг, так как сразу подсвечивает места, где данные не соответствуют ожидаемой структуре.

## 5. Процент использования
- 30% — AI (справка по типам событий React и Generic-синтаксису).
- 70% — Самостоятельная реализация логики поиска, фильтрации и финальная отладка приложения.