# AI REPORT
## Lab 03: React Components and Hooks — Props, State, useState, useEffect
### Student Name: Нурканат Алиар
### Lab 3.1: Component with State — Advanced Counter

## 1. Информация об использовании AI 
- **Инструмент:** Google Gemini
- **Дата:** 2026-01-31

## 2. Конкретные промпты

### Промпт 1:
"Объясни шаги в лабораторной работе"

**Что получил:** Структурированный план выполнения обеих частей лабы с выделением ключевых требований (useState, useEffect, AbortController).

### Промпт 2:
"Часть 1: Lab 3.1 — Продвинутый счетчик"

**Что получил:** Логику работы компонента `StepCounter`, пример управления массивом истории через `useState` и объяснение независимости состояний при композиции.

### Промпт 3:
"Как правильно выводить только последние 5 значений из массива истории?"

**Что получил:** Рекомендацию использовать метод `.slice(-5)` и `.reverse()` для корректного отображения последних действий.

## 3. Модификация и проверка
- **Типизация:** Настроил значения по умолчанию для пропсов (`initialValue = 0`), как того требовало задание.
- **Логика Reset:** Дописал функцию сброса так, чтобы она очищала не только число, но и массив истории, и счетчик операций.
- **Ручной ввод:** Весь код был набран вручную в редакторе.

## 4. Что узнал
- Понял, что изменение состояния (state) вызывает автоматический рендер компонента.
- Узнал, как передавать данные через пропсы и задавать им значения по умолчанию.
- Научился работать с массивами в состоянии (иммутабельное обновление через spread-оператор `[...]`).

## 5. Процент использования
- 15% — AI (объяснение структуры и логики обновления стейта).
- 85% — Самостоятельное написание кода, стилизация и отладка.

---

### Lab 3.2: Data Loading with useEffect

## 1. Информация об использовании AI
- **Инструмент:** Google Gemini
- **Дата:** 2026-01-31

## 2. Конкретные промпты

### Промпт 1:
"Часть 2: Lab 3.2 — Загрузка данных с useEffect"

**Что получил:** Объяснение жизненного цикла эффекта, пример асинхронной функции внутри `useEffect` и логику обработки состояний loading/error.

### Промпт 2:
"Зачем нужен AbortController в useEffect и как его реализовать?"

**Что получил:** Детальное объяснение предотвращения утечек памяти и "race conditions" (состояния гонки) при быстрой смене пропсов.

### Промпт 3:
"Как добавить userId в массив зависимостей, чтобы данные обновлялись при нажатии кнопок?"

**Что получил:** Пояснение о том, что `useEffect` перезапускается только тогда, когда меняются элементы, указанные в массиве `[]`.

## 3. Модификация и проверка
- **Валидация API:** Добавил проверку `response.ok`, так как `fetch` не выбрасывает ошибку при кодах 404 или 500.
- **Cleanup:** Реализовал функцию очистки `return () => abortController.abort()`.
- **UI:** Самостоятельно оформил карточку пользователя с использованием условного рендеринга.

## 4. Что узнал
- Освоил хук `useEffect` для выполнения побочных эффектов (запросы к API).
- Понял важность функции очистки (cleanup function) для оптимизации приложения.
- Научился связывать состояние родителя с эффектом в дочернем компоненте через массив зависимостей.

## 5. Процент использования
- 25% — AI (помощь с синтаксисом AbortController и логикой асинхронных запросов).
- 75% — Самостоятельная работа, настройка логики Refresh и верстка.